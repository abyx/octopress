<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | The Code Dump]]></title>
  <link href="http://www.codelord.net/category/ruby/atom.xml" rel="self"/>
  <link href="http://www.codelord.net/"/>
  <updated>2012-03-25T22:57:11+02:00</updated>
  <id>http://www.codelord.net/</id>
  <author>
    <name><![CDATA[Aviv Ben-Yosef]]></name>
    <email><![CDATA[aviv.by+blog@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Extend Your Toolbox: Custom Matchers]]></title>
    <link href="http://www.codelord.net/2012/02/04/extend-your-toolbox-custom-matchers/"/>
    <updated>2012-02-04T14:53:41+02:00</updated>
    <id>http://www.codelord.net/2012/02/04/extend-your-toolbox-custom-matchers</id>
    <content type="html"><![CDATA[<p>I'd like to point out a really nice testing practice that I've been loving more and more lately.</p>

<p>Just about every mature testing framework out there supports the concept of custom matchers, which provide us with the ability to define our very own assertions seamlessly into the tests. Even though this ability is quite old, we don't see it used too often and I think that's a shame. I've seen this practice heavily used in the mind expanding <a href="http://www.amazon.com/gp/product/0321503627?ie=UTF8&amp;tag=thcodu02-20&amp;linkCode=shr&amp;camp=213733&amp;creative=393185&amp;creativeASIN=0321503627">GOOS</a> book and just now am starting to realize its awesomeness.</p>

<p>Note: examples in this post are shown in Ruby using <a href="https://github.com/dchelimsky/rspec/wiki/Custom-Matchers">RSpec's matchers</a> but the concept is pretty much identical (as can be seen for example in Java's <a href="http://code.google.com/p/hamcrest/wiki/Tutorial">Hamcrest Matchers</a>).</p>

<h3>Matchers 101</h3>

<p>Creating your own matcher usually means creating a Matcher class that performs the assertions, supplies human readable error messages and a nice constructor.</p>

<p>Here's an example from the <a href="https://github.com/dchelimsky/rspec/wiki/Custom-Matchers">RSpec documentation</a>:</p>

<p><div><script src='https://gist.github.com/1737631.js?file=rspec_matcher.rb'></script>
<noscript><pre><code>RSpec::Matchers.define :be_a_multiple_of do |expected|
  match do |actual|
    actual % expected == 0
  end
end</code></pre></noscript></div>
</p>

<h3>Matchers increase readability and intent</h3>

<p>As you should know, one of the <a href="http://c2.com/cgi/wiki?XpSimplicityRules">most important rules for design</a> is <em>Reveals Intent</em>. Take a quick look here, which way do you think reveals more intent?</p>

<p><div><script src='https://gist.github.com/1737631.js?file=intent.rb'></script>
<noscript><pre><code># This
response['X-Runtime'].should =~ /[\d\.]+/

# .. or this?
response['X-Runtime'].should be_a_number</code></pre></noscript></div>
</p>

<p>Also, which error message do you prefer? "expected false to be true" or something along the lines of "expected comment to be anonymous"?</p>

<h3>Matchers create robust tests</h3>

<p>The most important advantage of all is how using matchers easily allows you to steer away from fragile tests which are the bane of a lot of testing efforts.
The mark of good tests is that a change in your code doesn't require you to perform changes in multiple tests that don't really care for the change.
Take this code for example:</p>

<p><div><script src='https://gist.github.com/1737631.js?file=sucky_non_dry.rb'></script>
<noscript><pre><code>expected_comment = Comment.new(anonymous: true, user: &quot;the dude&quot;, reply_to: nil)
commentor.should_receive(:add).with(expected_comment)</code></pre></noscript></div>
</p>

<p>This might seem like a standard test, but that's not really the case. A test should assert for a single piece of knowledge, and this test actually checks several. If the purpose of this test is to check the behavior of anonymous comments, why should it change if we no longer allow replies? Or if we no longer require users for posting comments?</p>

<p>The magic of matchers is exactly here. You create a new matcher to check specifically the aspect your test cares about and <em>boom</em>, you're decoupled!</p>

<p><div><script src='https://gist.github.com/1737631.js?file=beautiful_and_dry.rb'></script>
<noscript><pre><code>commentor.should_receive(:add).with(anonymous_comment)</code></pre></noscript></div>
</p>

<p>This simple change makes your tests DRY and cool.</p>

<p>Happy testing!</p>

<p>Your should <a href="http://feeds.feedburner.com/TheCodeDump">subscribe</a> to my feed or <a href="http://twitter.com/avivby">follow</a> me on twitter!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TIL: Ruby Classes that Look Callable]]></title>
    <link href="http://www.codelord.net/2011/10/18/til-ruby-classes-that-look-callable/"/>
    <updated>2011-10-18T08:01:07+02:00</updated>
    <id>http://www.codelord.net/2011/10/18/til-ruby-classes-that-look-callable</id>
    <content type="html"><![CDATA[<p>One of the concept I had to get used to moving from Python to Ruby was that regular objects aren't callable, and that there was a closed set of objects that can be called. Meaning that where in Python it was possible for any class to implement <strong>call</strong> and so allow us to call it with obj(), Ruby doesn't allow this. One of the advantages of that syntax in Python is that each class implements its constructor using this. For example:</p>

<p><div><script src='https://gist.github.com/1294707.js?file=python_class_is_callable.py'></script>
<noscript><pre><code>class MyClass:
    def __init__(self, value):
        self.value = value

my_class = MyClass(1) # We are calling the class to get
                      # an instance, instead of
                      # MyClass.new(1) in Ruby</code></pre></noscript></div>
</p>

<p>This was a nice little trick I liked in Python but quickly got used to living without it. That was until I saw Ruby code that seemed to allow the exact same behavior:</p>

<p><div><script src='https://gist.github.com/1294707.js?file=ruby_class_looks_callable.rb'></script>
<noscript><pre><code>Integer.class
#=&gt; Class

Integer(1)
#=&gt; 1</code></pre></noscript></div>
</p>

<p>How's this so? Can we really make classes callable? A quick glance at Integer's source code in the Rubinius code reveals that there's no magic going on in it, and that it actually has no reference for this method I'm looking to call. Instead what we'll see is that alongside the class definition there's also a method definition:</p>

<p><div><script src='https://gist.github.com/1294707.js?file=integer.rb'></script>
<noscript><pre><code>class Integer
  #...
end

def Integer(value)
  #...
end</code></pre></noscript></div>
</p>

<p>So the whole trick is simply to define both. But how exactly does this work? How are names not clashing?</p>

<p>What actually happens is that whenever we define a new class or module, its name is added as a constant that points to the actual class. Similarly, when we define a method at the top level it's added as a private method to Object. That means that whenever we type in a name that looks like a constant (starts with a capital letter) without parenthesis, Ruby will search for that constant:</p>

<p><div><script src='https://gist.github.com/1294707.js?file=const_lookup.rb'></script>
<noscript><pre><code>Object.const_defined? :Integer
#=&gt; true</code></pre></noscript></div>
</p>

<p>But when we add parenthesis, Ruby understands that it should seek for a method instead:</p>

<p><div><script src='https://gist.github.com/1294707.js?file=method_lookup.rb'></script>
<noscript><pre><code>Object.private_method_defined? :Integer
#=&gt; true</code></pre></noscript></div>
</p>

<p>This nifty little trick is all it takes for Ruby to allow this nice syntax.</p>

<p>Hope you learned a new thing! In case you want to dig deeper, two great books that really helped me wrap my head around dark corners of Ruby are <a href="http://www.amazon.com/gp/product/0321584104/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=thcodu02-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321584104">Eloquent Ruby</a> and <a href="http://www.amazon.com/gp/product/1934356476/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=thcodu02-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1934356476">Metaprogramming Ruby</a>.</p>

<p>You should <a href="http://feeds.feedburner.com/TheCodeDump">subscribe</a> to my feed and <a href="http://twitter.com/avivby">follow</a> me on twitter!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Submitting your first patch to Rubinius]]></title>
    <link href="http://www.codelord.net/2011/10/11/submitting-your-first-patch-to-rubinius/"/>
    <updated>2011-10-11T07:02:04+02:00</updated>
    <id>http://www.codelord.net/2011/10/11/submitting-your-first-patch-to-rubinius</id>
    <content type="html"><![CDATA[<p>I always love helping interesting open source projects, and Rubinius is one of those great projects that are very cool to play with. In case you don't know it, Rubinius is a Ruby implementation written (almost) entirely in Ruby. Just playing with such a code base is quite interesting and whenever a peek around in the code I learn new stuff about Ruby.</p>

<p>At the moment, the people at Rubinius are working hard on making it compatible with ruby 1.9, and so there are a lot of easy changes that are waiting for you to do and start contributing. I'd like to show you a quick walk-through of how to find such simple tasks and get started.</p>

<h3>Setup</h3>

<p>Clone the project from the GitHub <a href="https://github.com/rubinius/rubinius">repo</a>. Once that's done, to make sure that everything works properly do this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>./configure
</span><span class='line'>rake spec
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The specs should be all passing on your machine. It will take a few minutes the first time, but afterwards whenever you make small changes it will be faster.</p>

<h3>Finding interesting work</h3>

<p>Of course you can submit whatever patch you find interesting, but in my opinion a quick way to get started is to find incompatibilities with 1.9. Fortunately for you, it's pretty easy to find those.</p>

<p>Rubinius, along with the other Ruby implementations, uses mspec in order to have written specs of the language written in Ruby and is checked against that. These specs are similar to RSpec. Among other options, some specs are simply marked as having to pass only on Ruby 1.9 and of these, those that are currently failing are our hunt.</p>

<p>I came up with this command in order to find and execute such 1.9 specs that were last reported by Rubinius developers to be failing:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>bin/mspec tag --list fails -tx19 :ci_files
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This command will list the RubySpecs that are tagged as failing on Rubinius in 1.9 mode.</p>

<p>You should see plenty (at the time of this writing, over 500) of failing specs. Just pick something that seems easy enough to get started with.</p>

<p>Once you spot a spec that looks interesting you can run it specifically and see the code. For example, if you see an interesting spec for String#squeeze, you can run it with:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>bin/mspec -tx19 spec/ruby/core/string/squeeze_spec.rb
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>Doing some work</h3>

<p>For example, let's look at one of the really simple specs I decided to get passing, you can see the commit <a href="https://github.com/rubinius/rubinius/commit/723fc5ee6c57267c92744b24a100c595375ef39c">here</a>. I wanted to make a simple change to the String#ord method, but only on 1.9 version. The way to do that on Rubinius is that many of the files, say string.rb now have also "string18.rb" and "string19.rb" that contain the code that differs. In my case, I just made a simple change to the version used on 1.9 by editing the ord method on the string19.rb file (in case the 19 and 18 files don't exist yet, you can simply create them like shown <a href="https://github.com/rubinius/rubinius/commit/42fe03c5e6b82b712dcdbdf5875581f854e21af7">here</a>).</p>

<p>After you've made your changes, be sure to run the specs again and see that everything works. Before submitting it, you should make sure to run all specs thoroughly using the command rake spec. If all is well, just do the regular GitHub <a href="http://help.github.com/send-pull-requests/">pull-request dance</a> and off you go!</p>

<p>Further than that, you can include in your pull request another commit that removes the failing tags from the specs you've just fixed. Find the appropriate file and just remove it, as you can see in <a href="https://github.com/rubinius/rubinius/commit/bfde3637a454eade1972a636dd8a1ad05d9fdc57">this commit</a>.</p>

<p>For some more in depth review of how to start contributing to Rubinius, see this <a href="http://rubini.us/2011/10/18/contributing-to-rubinius/">excellent post</a> on the official blog.</p>

<p>You should subscribe to my <a href="http://feeds.feedburner.com/TheCodeDump">feed</a> and follow me on <a href="http://twitter.com/avivby">twitter</a>!</p>
]]></content>
  </entry>
  
</feed>
