<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tdd | The Code Dump]]></title>
  <link href="http://www.codelord.net/category/tdd/atom.xml" rel="self"/>
  <link href="http://www.codelord.net/"/>
  <updated>2012-03-25T20:33:29+02:00</updated>
  <id>http://www.codelord.net/</id>
  <author>
    <name><![CDATA[Aviv Ben-Yosef]]></name>
    <email><![CDATA[aviv.by+blog@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Notes from the Agile Practitioners 2012 Improving Your TDD Workshop]]></title>
    <link href="http://www.codelord.net/2012/03/01/notes-from-the-agile-practitioners-2012-improving-your-tdd-workshop/"/>
    <updated>2012-03-01T08:01:16+02:00</updated>
    <id>http://www.codelord.net/2012/03/01/notes-from-the-agile-practitioners-2012-improving-your-tdd-workshop</id>
    <content type="html"><![CDATA[<p><blockquote><p>If you write a test and it passes, the question is if the previous step was too big.<br/>The DRY principle doesn't talk about code, but knowledge.<br/>Clever is never something to be proud of in your code.</p><footer><strong>Corey Haines</strong> <cite>Improving Your TDD</cite></footer></blockquote></p>

<p>A couple of days after <a href="/2012/02/28/notes-from-the-israeli-software-craftsmanship-group-code-retreat/">attending the code retreat</a> facilitated by him, I was fortunate to attend Corey Haines's “<a href="http://agilepractitioners2012.com/conference-program/corey-haines-improving-your-tdd/">Improving Your TDD</a>” workshop at the <a href="http://agilepractitioners2012.com/">Agile Practitioners 2012</a> conference. These are some of my notes from the day.</p>

<p>The workshop was intended at coders familiar with TDD and not introductory. I was very interested to see how in-depth TDD training looks, and also meet other coders from Israel that have been doing TDD for a few years. It was quite awesome to sit in a room where everyone felt comfortable with TDD and it wasn't this new and hard thing. When the group shares this "advanced" technique, discussion can suddenly level up and we could all dive in to the nitty gritty stuff.</p>

<p>During the day, Corey walked us through pretty much taking TDD apart and putting it back together. We started from the history of TDD and its predecessors (manual verification, test after, test first, etc.).</p>

<p>The exercises throughout the day (that I especially enjoyed since I was pairing with <a href="http://twitter.com/theyonibomber">@theyonibomber</a>, my original pair as we were learning TDD together back in 2006) had this beautiful flow of making you smack right into a problem in the way most people do TDD.</p>

<p>We discussed having the tests drive an implementation that we knew we did not want (like sorting easily become bubble sort) and how the (relatively new) <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">Transformation Priority Premise</a> by Uncle Bob can help solve this.</p>

<p>We then took another introspective look at our TDD process (aided by an exercise once more) that made us face the problem of "flailing" and "sitting in red" - basically the problem of trying to take a step too big in the next test and so falling off the good fast rhythm of "<a href="http://programmingtour.blogspot.com/2009/03/time-to-green-graphs-with-gary.html">time to green</a>".</p>

<p>We had a long discussion about these problems and how they are directly connected to the way we pick the next test. We all know that the next test should be the "simplest thing", but how exactly do we define simple?</p>

<p>I love having these discussions that jolt me and make me rethinks stuff I've long ago stopped paying attention to. Developer introspection is a thing of beauty and much power (Kent Beck tells that he wrote his incredible <a href="http://www.amazon.com/gp/product/013476904X/ref=as_li_ss_tl?ie=UTF8&amp;tag=thcodu02-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=013476904X">Smalltalk Best Practice Patterns</a><img src="http://www.assoc-amazon.com/e/ir?t=thcodu02-20&l=as2&o=1&a=013476904X" style="width: 0; height: 0; display: none; border: none !important;"/> and <a href="http://www.amazon.com/gp/product/0321413091/ref=as_li_ss_tl?ie=UTF8&amp;tag=thcodu02-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0321413091">Implementation Patterns</a> <img src="http://www.assoc-amazon.com/e/ir?t=thcodu02-20&l=as2&o=1&a=0321413091" style="width: 0; height: 0; display: none; border: none !important;"/>  books by simply stopping whenever he was about to type some code and have an explanation as to why he picked to do it that way).</p>

<p>Corey even did a live demo of his TDD style and programming by wishful thinking. It was very interesting, but as all live demos go he had some trouble along the way. Workshop aside, it is not trivial for someone giving a training to admit a mistake done, and Corey gracefully handled the situation.</p>

<p>All in all, the day was a very productive one and it still has me chewing on some of the lessons we learned. It's fun realizing again that there's no limit to how much one can sharpen a specific skill. Hat off to Corey and the conference organizers for making this happen!</p>

<p>You should <a href="http://feeds.feedburner.com/TheCodeDump">subscribe</a> to my feed or <a href="http://twitter.com/avivby">follow</a> me on twitter!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extend Your Toolbox: Custom Matchers]]></title>
    <link href="http://www.codelord.net/2012/02/04/extend-your-toolbox-custom-matchers/"/>
    <updated>2012-02-04T14:53:41+02:00</updated>
    <id>http://www.codelord.net/2012/02/04/extend-your-toolbox-custom-matchers</id>
    <content type="html"><![CDATA[<p>I'd like to point out a really nice testing practice that I've been loving more and more lately.</p>

<p>Just about every mature testing framework out there supports the concept of custom matchers, which provide us with the ability to define our very own assertions seamlessly into the tests. Even though this ability is quite old, we don't see it used too often and I think that's a shame. I've seen this practice heavily used in the mind expanding <a href="http://www.amazon.com/gp/product/0321503627?ie=UTF8&amp;tag=thcodu02-20&amp;linkCode=shr&amp;camp=213733&amp;creative=393185&amp;creativeASIN=0321503627">GOOS</a> book and just now am starting to realize its awesomeness.</p>

<p>Note: examples in this post are shown in Ruby using <a href="https://github.com/dchelimsky/rspec/wiki/Custom-Matchers">RSpec's matchers</a> but the concept is pretty much identical (as can be seen for example in Java's <a href="http://code.google.com/p/hamcrest/wiki/Tutorial">Hamcrest Matchers</a>).</p>

<h3>Matchers 101</h3>

<p>Creating your own matcher usually means creating a Matcher class that performs the assertions, supplies human readable error messages and a nice constructor.</p>

<p>Here's an example from the <a href="https://github.com/dchelimsky/rspec/wiki/Custom-Matchers">RSpec documentation</a>:</p>

<p><div><script src='https://gist.github.com/1737631.js?file=rspec_matcher.rb'></script>
<noscript><pre><code>RSpec::Matchers.define :be_a_multiple_of do |expected|
  match do |actual|
    actual % expected == 0
  end
end</code></pre></noscript></div>
</p>

<h3>Matchers increase readability and intent</h3>

<p>As you should know, one of the <a href="http://c2.com/cgi/wiki?XpSimplicityRules">most important rules for design</a> is <em>Reveals Intent</em>. Take a quick look here, which way do you think reveals more intent?</p>

<p><div><script src='https://gist.github.com/1737631.js?file=intent.rb'></script>
<noscript><pre><code># This
response['X-Runtime'].should =~ /[\d\.]+/

# .. or this?
response['X-Runtime'].should be_a_number</code></pre></noscript></div>
</p>

<p>Also, which error message do you prefer? "expected false to be true" or something along the lines of "expected comment to be anonymous"?</p>

<h3>Matchers create robust tests</h3>

<p>The most important advantage of all is how using matchers easily allows you to steer away from fragile tests which are the bane of a lot of testing efforts.
The mark of good tests is that a change in your code doesn't require you to perform changes in multiple tests that don't really care for the change.
Take this code for example:</p>

<p><div><script src='https://gist.github.com/1737631.js?file=sucky_non_dry.rb'></script>
<noscript><pre><code>expected_comment = Comment.new(anonymous: true, user: &quot;the dude&quot;, reply_to: nil)
commentor.should_receive(:add).with(expected_comment)</code></pre></noscript></div>
</p>

<p>This might seem like a standard test, but that's not really the case. A test should assert for a single piece of knowledge, and this test actually checks several. If the purpose of this test is to check the behavior of anonymous comments, why should it change if we no longer allow replies? Or if we no longer require users for posting comments?</p>

<p>The magic of matchers is exactly here. You create a new matcher to check specifically the aspect your test cares about and <em>boom</em>, you're decoupled!</p>

<p><div><script src='https://gist.github.com/1737631.js?file=beautiful_and_dry.rb'></script>
<noscript><pre><code>commentor.should_receive(:add).with(anonymous_comment)</code></pre></noscript></div>
</p>

<p>This simple change makes your tests DRY and cool.</p>

<p>Happy testing!</p>

<p>Your should <a href="http://feeds.feedburner.com/TheCodeDump">subscribe</a> to my feed or <a href="http://twitter.com/avivby">follow</a> me on twitter!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Looking Back on 18 months of Testing and TDD at a Startup]]></title>
    <link href="http://www.codelord.net/2012/01/06/looking-back-on-18-months-of-testing-and-tdd-at-a-startup/"/>
    <updated>2012-01-06T22:34:25+02:00</updated>
    <id>http://www.codelord.net/2012/01/06/looking-back-on-18-months-of-testing-and-tdd-at-a-startup</id>
    <content type="html"><![CDATA[<p>As we're approaching a year and half here at <a href="https://www.billguard.com">BillGuard</a>, I've started thinking back a bit about our testing habits and how well that's turned out.</p>

<p>I've seen a lot of posts about testing in startups, some saying startups shouldn't bother to test because they'll have to change the whole damn thing 5 minutes after they're done, others claim testing is the only reason they were able to keep working. Here are some of my thoughts looking back.</p>

<h3>Our Background</h3>

<p>When we started, only two of us had a test-infected background out of the five technical guys, me being big on <a href="http://www.amazon.com/gp/product/0321146530/ref=as_li_ss_tl?ie=UTF8&amp;tag=thcodu02-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0321146530">TDD</a><img src="http://www.assoc-amazon.com/e/ir?t=thcodu02-20&l=as2&o=1&a=0321146530" style="width: 0; height: 0; display: none; border: none !important;">. Two other developers never wrote tests before. We agreed that tests were important, but that's about it. I set up a continuous integration server and with that we were off. With time, the habit of writing tests spread out among the team. Some are TDD passionate, some write tests after the fact, but we generally all believe that tests should be written extensively.</p>

<p><img src="/images/posts_images/test_my_code.png" width="240" height="300"></p>

<h3>Not everything is worth testing</h3>

<p>We've seen several quite rapid changes to our UI. Having less tests in this area makes sense. We rely on QA for making sure all buttons are displayed etc. To make this clear: we have no selenium-like tests for UI components but have tests for most logic being done by the UI. I think this is generally a good practice, since having to maintain selenium tests would be hard when you throw things around a lot and change flows. Some basic automated sanity tests pretty much does it.</p>

<h3>Everyone learned to love tests</h3>

<p>I love seeing other guys in the team delete a line of code to see which test breaks and understand why it's there. Even more I love the frowning face when no tests break. This addiction to tests shows how much value the team's getting out of having solid tests, hands down. No need to stress this further I believe.</p>

<h3>Tests save our asses repeatedly</h3>

<p>Having an extensive suite of tests allows us to make rapid changes to our code base, as is needed in most startups, and rely on the solid tests to tell us whether we've screwed something up. All the code that has anything whatsoever to do with sensitive and important information is heavily tested which is a huge bonus and a necessity in our line of business (personal finance protection).</p>

<h3>TDD is just magical with complex algorithms</h3>

<p>We have quite a few complex algorithms that require multiple entities and ideas to perform. I find that the parts we're most satisfied with maintainability-wise are the heavily TDD-ed algorithms we've got. Being written with rigorous TDD gives us so many advantages:</p>

<ul>
<li>This critical code usually has a lot less defects.</li>
<li>The code is a lot more readable, well decomposed and allows for easy changing once we find out a need for tweaking the algorithms.</li>
<li>Working in TDD magically forces us to form our problem domain better, making us have a language of our own in talking about the problem. This happens less naturally in other forms of working on algorithms.</li>
</ul>


<h3>Summing our testing experiences</h3>

<p>All in all, I think the whole team would agree that dedicating time to writing thorough tests is proving itself valuable and because of that people are writing more and more tests without any of us ever stopping and saying "we should write tests" (well, I swear I didn't do it too much). It happens naturally when people get the value out of it. It's fun seeing how today BillGuard has become a company that organically values testing so much I don't even feel a great need to stress it to new people because they'll quickly see there's no real other way. We're far from being the poster children of <a href="http://www.amazon.com/gp/product/0132350882/ref=as_li_ss_tl?ie=UTF8&amp;tag=thcodu02-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0132350882">Clean Code</a><img src="http://www.assoc-amazon.com/e/ir?t=thcodu02-20&l=as2&o=1&a=0132350882" style="width: 0; height: 0; display: none; border: none !important;">, but I've got my fingers crossed.</p>

<p>If you're interested in accomplishing the same at your work, you might find <a href="/2011/11/28/stop-bitching-write-those-damn-tests/">this recent post</a> of mine of some help.</p>

<p>You should <a href="http://feeds.feedburner.com/TheCodeDump">subscribe</a> to my feed or <a href="http://twitter.com/avivby">follow</a> me on twitter!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fight Zombie Code]]></title>
    <link href="http://www.codelord.net/2011/10/28/fight-zombie-code/"/>
    <updated>2011-10-28T16:57:27+02:00</updated>
    <id>http://www.codelord.net/2011/10/28/fight-zombie-code</id>
    <content type="html"><![CDATA[<p>If there's anything I hate more than dead code, it's zombie code. Dead code is code that's remained in the system even though it's no longer really used.</p>

<p>It might be small, like unused imports, instance variables and methods. It can be whole classes that make up entire features no longer used.</p>

<p>The biggest PITA is when you're not really aware of the fact the code's dead and unused, sitting there and occupying precious bits, and stumble across it as part of a task, trying to understand how it influences what you want to do next.</p>

<p>Whenever I recognized something that looks like dead code but I'm not entirely sure, I find it pretty easy to delete it quickly, once I take a look in the version control logs and see when it became no longer in use and why.</p>

<p>Zombie code is code that was never alive, and so couldn't really become dead. It's the undead code - code that died right when it was committed. Code that never ran or never worked. The are two reasons I hate zombie code more than "plain" dead code.</p>

<p><img src="/images/posts_images/test_my_code.png" width="240" height="300"></p>

<p>The first reason is that it simply wastes more of my time. Looking back in version control won't help me see the commit in which the code was "decommissioned", it would just appear to always sit there. That means I have to take extra care to verify that it, in fact, never worked.</p>

<p>The second reason is that it's plainly someone saying he doesn't give a damn. I mean, let's put aside TDD. Heck, let's put aside unit testing at all. It means the code never even ran the damn thing and saw in his own eyes it did what he claims it did.</p>

<p>Be kind to your teammates. If you're not a good enough coder to test it, at least see that it runs <em>once</em> in your own eyes.</p>

<p>You should <a href="http://feeds.feedburner.com/TheCodeDump">subscribe</a> to my feed and <a href="http://twitter.com/avivby">follow</a> me on twitter!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Today I Got Burnt by Isolated Tests]]></title>
    <link href="http://www.codelord.net/2011/08/07/today-i-got-burnt-by-isolated-tests/"/>
    <updated>2011-08-07T23:06:26+03:00</updated>
    <id>http://www.codelord.net/2011/08/07/today-i-got-burnt-by-isolated-tests</id>
    <content type="html"><![CDATA[<p>Generally, I prefer the <a href="http://www.amazon.com/gp/product/0321503627/ref=as_li_tf_tl?ie=UTF8&amp;tag=thcodu02-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321503627">GOOS</a><img src="http://www.assoc-amazon.com/e/ir?t=thcodu02-20&l=as2&o=1&a=0321503627" style="width: 0; height: 0; display: none; border: none !important;"> school of TDD which includes isolating my classes as much as possible, putting mocks and stubs everywhere. Even though one of its known disadvantages is that you risk testing your classes in a fake environment that won't match the real production code using it, I've rarely come across a place where I got really bitten by it.</p>

<p>Today I set out with my pair to add some functionality to a certain class. That class had about 30-40 lines of code and about 10 test cases, which seemed quite decent. We added our changes TDD style and just couldn't get the thing working. After digging into it for a few more minutes we suddenly realized the class shouldn't be working at all and checking in the DB showed that indeed the last time that specific feature had any effect was 3 months ago!</p>

<p>Fortunately for us, all the problems that caused this bug are solved problems, we just need to get better at implementing the solutions:</p>

<p>Isolated tests go much better hand in hand with a few <strong><em>integration tests</em></strong> (some might say the right term is acceptance tests) that execute the whole system and make sure the features are working. Had we had those, we would have caught the bug much sooner.</p>

<p>The bug was introduced in a <strong><em>huge commit</em></strong> that changes 35 files and 1500 lines of code. We usually try and go over every commit made, even if it was paired, because we believe in collective code ownership, but it's impossible to go over such a huge diff and find these intricacies. Working in small baby steps makes it far less likely to break something and more likely that someone else will spot your mistakes. Huge refactorings give me the creeps.</p>

<p>After the change was committed, it was not <strong><em>followed-through</em></strong>: this specific feature is a feature you usually notice over a few days and we missed out on making sure it kept working. We moved on to other tasks and forgot all about it, thinking it was working all this time. Had we taken the time to make sure we were seeing, it would have been squashed by the next deployment.</p>

<p>Any of these would have helped us spot sooner that the isolated tests were actually testing the code against a scenario that never happens. These tiny changes of our workflow would have made several of our users happier over this timeframe.</p>

<p>Hopefully all is well now and the feature is back at 100%, but only time will tell whether we were able to learn from this mishap.</p>

<p>You should <a href="http://feeds.feedburner.com/TheCodeDump">subscribe</a> to my feed and <a href="http://twitter.com/avivby">follow</a> me on twitter!</p>
]]></content>
  </entry>
  
</feed>
