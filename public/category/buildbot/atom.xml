<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: buildbot | The Code Dump]]></title>
  <link href="http://www.codelord.net/category/buildbot/atom.xml" rel="self"/>
  <link href="http://www.codelord.net/"/>
  <updated>2012-03-25T22:57:11+02:00</updated>
  <id>http://www.codelord.net/</id>
  <author>
    <name><![CDATA[Aviv Ben-Yosef]]></name>
    <email><![CDATA[aviv.by+blog@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python (nose) Test Coverage on Buildbot]]></title>
    <link href="http://www.codelord.net/2010/05/09/python-nose-test-coverage-on-buildbot/"/>
    <updated>2010-05-09T19:03:07+03:00</updated>
    <id>http://www.codelord.net/2010/05/09/python-nose-test-coverage-on-buildbot</id>
    <content type="html"><![CDATA[<p>Once we got our builds happily running on Buildbot, there's really no reason not to add coverage since it's so easy (especially if you get bragging rights over your non-TDDers teammates).</p>

<p>All you have to do is this (code is based on this <a href="http://copypasteprogrammer.blogspot.com/2010/03/buildbot-and-nose-test-coverage.html">blog post</a>, with adaptations to work on slaves that don't share directories with the master, since the createSummary method runs on the master):</p>

<p><div><script src='https://gist.github.com/395269.js?file='></script>
<noscript><pre><code>from buildbot.process.properties import WithProperties
from buildbot.steps.shell import ShellCommand
from buildbot.interface import LOG_CHANNEL_STDERR as STDERR

class Nose(ShellCommand):
    def __init__(self):
        self.coverage_path = '/var/www/foo/coverage-%s'
        self.coverage_url = 'http://example.com/foo/coverage-%s'
        d = WithProperties('--cover-html-dir=' + self.coverage_path, 
                           'buildnumber')
        command = ['nosetests', '--with-coverage', '--cover-erase', 
                   '--cover-html', d]
        ShellCommand.__init__(self, command=command)
    
    def createSummary(self, log):
        buildnumber = self.getProperty('buildnumber')
        coverage_index = ((self.coverage_path + '/index.html')
                          % buildnumber)
        lines = [line.strip() for line in
                 log.readlines(channel=STDERR)]
        percentage = 'N/A'
        for line in lines:
            if line.startswith('TOTAL'):
                percentage = line.split()[-1]
                break
        
        self.addURL(&quot;coverage %s&quot; % percentage,
                    self.coverage_url % buildnumber)
</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing a BuildBot Latent Build Slave]]></title>
    <link href="http://www.codelord.net/2009/10/04/writing-a-buildbot-latent-build-slave/"/>
    <updated>2009-10-04T21:33:24+02:00</updated>
    <id>http://www.codelord.net/2009/10/04/writing-a-buildbot-latent-build-slave</id>
    <content type="html"><![CDATA[<p>We've been working on creating a scalable and stable building and testing environment for our team.
After some checking, <a href="http://buildbot.net">BuildBot</a> was found to be the best (for our needs, at least).</p>

<p>Gathering the different abilities that are needed for testing our products, and the different limitations we've got in our testing lab, we came to the conclusion that using some sort of distribution framework is needed. Being the code monkeys that we are, we started designing a whole solution for integrating BuildBot with our distribution framework of choice, when looking at the BuildBot manual I saw it already has support for this concept, the Latent Buildslave !</p>

<p>One small thing is, that adding support for a new one isn't so clear. The <a href="http://djmitche.github.com/buildbot/docs/0.7.11/#Writing-New-Latent-Buildslaves">manual</a> simply states that one needs just to implement <code>start_instance</code> and <code>stop_instance</code> methods and be done with it, but, in my opinion, lacks some details, so here is what we figured:</p>

<ol>
<li>The <code>start_instance</code> method should return a <a href="http://twistedmatrix.com/projects/core/documentation/howto/defer.html"><code>deferred</code></a> that, when called, will return once a new build slave is ready to go.</li>
<li>How do you return the new slave's IP to BuildBot? No need! Once it will be connected, the master will figure it's the one you just created (via <code>AbstractLatentBuildSlave.attached</code>).</li>
<li>The actual value returned from <code>start_instance</code> is pretty insignificant (will be printed to the log, as the manual states).</li>
<li>The <code>stop_instance</code> method is pretty much the same, and should take care of making the distribution framework aware that the allocated buildslave is free to be destroyed/reused.</li>
</ol>


<h3>Why don't my latent slaves die?</h3>

<p>As you may have noticed, once <code>start_instance</code> is called and a slave connects to the master, BuildBot is in no hurry to call your <code>stop_instance</code> once the build is completed. Actually, as far as BuildBot is concerned, that slave is there to stay (at least, as far as we figured). In case you'd rather to generate a new slave for each build, you will need to override the <code>buildFinished</code> method of the abstract slave, and in it call the <code>unsubstantiate</code> method. A bit of a headache, but that's the way it is.</p>

<p>Happy testing!</p>

<p>P.S. If you're using the latest BuildBot (from the git repository), try out the Console view, it's really awesome!</p>

<p>You should follow me on twitter <a href="http://twitter.com/avivby">here</a>.</p>
]]></content>
  </entry>
  
</feed>
